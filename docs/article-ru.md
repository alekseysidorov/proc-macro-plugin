# Расширяем возможности процедурных макросов с помощью WASM

В рамках продолжения своих исследований различных аспектов процедурных макросов хочу поделиться
подходом к расширению их возможностей. Напомню, что процедурные макросы позволяют добавить в язык
элемент метапрограммирования и тем самым существенно упростить рутинные операции, такие как
сериализация или обработка запросов. По своей сути макросы являются плагинами к компилятору,
которые компилируются до сборки крейта, в котором они используются. У таких макросов есть некоторые
существенные недостатки.

- Сложность с поддержкой таких макросов в IDE. По сути дела нужно как-то научить анализатор кода
  самостоятельно компилировать, загружать и исполнять эти самые макросы с учетом всех особенностей.
  Это весьма нетривиальная задача.
- Так как макросы самодостаточные и ничего не знают друг о друге, то нет никакой возможности делать
  композицию макросов, что иногда могло быть полезным.

## Обзор того, что мы хотим получить

По поводу решения первой проблемы сейчас ведутся [эксперименты][watt] с компиляцией всех
процедурных макросов в WASM модули, что позволит в будущем вообще отказаться от их компиляции
на целевой машине, а заодно и решить проблему с их поддержкой в IDE.

Что касается второй проблемы, то в этой статье я как раз собираюсь рассказать о своем подходе
к решению данной проблемы. По сути дела нам необходим такой макрос, который бы мог с помощью
атрибутов подгружать какие-то дополнительные макросы и объединять их в конвеер. В самом простейшем
случае можно просто представить нечто в роде такого:

Пусть у нас имеется некоторый макрос `TextMessage`, который выводит для заданного типа трейты
`ToString` и `FromStr` используя в качестве текстового представления некоторый кодек.
У разных типов сообщений может быть различный кодек, причем их полный список со временем
может расширятся, а у каждого кодека может быть свой уникальный набор атрибутов.

```rust
#[derive(Debug, Serialize, Deserialize, PartialEq, TextMessage)]
#[text_message(codec = "serde_json", params(pretty))]
struct FooMessage {
    name: String,
    description: String,
    value: u64,
}
```

Чтобы сделать такой макрос возможным, мы должны динамически подгружать реализации кодеков
в процессе выполнения макроса. Можно вынести кодеки в подключаемую библиотеку и просто загружать
их через [libloading], но это очень неудобно и еще больше отдалит нас от возможности поддержки
макросов в IDE. Вместо этого теоретически возможно написать такой вот кодек на динамическом языке
типа Питона, но тогда нам придется писать для Питона аналоги [`syn`] и [`quote`], что будет больше
напоминать Сизифов труд, чем реальное решение проблемы.
Наиболее же простым и удобным видится вариант скомпилировать кодек в WASM модуль, объединив плюсы
обоих подходов. Именно таким путем я предлагаю и пойти.

## Выбор подхода и сравнение с watt

На первый взгляд кажется, что проблема уже решена в рамках [watt] и можно просто использовать его
для загрузки и выполнения WASM модулей, но с этим подходом есть один весьма неприятный недостаток.
Для своей работы [watt] использует модифицированный крейт [`proc-macro2`], что частенько приводит к
непонятным или трудноуловимым проблемам. Например, у меня не компилировался `darling` или если я
забывал подменять `proc-macro2`, то получал в рантайме неочевидные ошибки.

В результае я решил, что лучше уж пользоваться ванильным [`proc-macro2`], а в качестве WASM
рантайма взять какой-нибудь из самых популярных. В результате, мой субьективный выбор пал на
[wasmtime], этот рантайм разрабатывается сообществом [bytecodealliance], в состав которого входят
такие гиганты, как Mozilla, Intel и RedHat. И хотя [wasmtime] сейчас выглядит еще достаточно сырым,
в нем не хватает документации, хороших примеров, но развивается он очень быстро и улучшается прямо
на глазах

## Рассказ про FFI между хостом и таргетом

**Disclaimer**: этот раздел писался еще до того, появилась возможность генерировать
[интерфейс модуля] при помощи макросов. С другой стороны, в нем рассматривается самая
низкоуровневая работа с WASM модулями, что позволяет нам лучше понять принцип его работы.
Погнали!

В самом простом виде интерфейс плагина для нашего процедурного макроса должен представлять из себя
вариацию на тему:

```rust
pub fn implement_codec(input: TokenStream) -> TokenStream;
```

Но мы не можем передавать произвольные объекты между таргетом и хостом, нам необходимо
их сериализовать в универсальное представление, которое не будет зависить от особенностей хоста.
По счастью `TokenStream` можно преобразовывать в обычную строку и обратно, поэтому в реальности
мы будем использовать нечто в таком духе:

```rust
pub fn implement_codec(input: &str) -> String;
```

К великому сожалению, вот так просто взять и передать хостовую строчку, а уж тем более
передать строчку от таргета к хосту, не получится и на то есть серьезные причины:

В целях обеспечения безопасности ~~и большей стабильности, Республика будет реорганизована нами в
первую Галактическую Империю, во имя сохранности и во имя блага общества!~~ память WASM рантайма
отделена от хостовой, с точки зрения хоста это просто плоский массив байт, в котором находится
код программы, глобальные переменные, стек и куча. Есть возможность сделать так, чтобы память была
расширяемой, то если если при очередном выделении памяти нам не хватает места, то верхняя граница
памяти автоматически увеличивается. Индекс ячейки в этом самом массиве используется в качестве
указателя внутри таргета, но мы не можем просто взять и записать строчку в случайный участок
памяти и отдать таргету индекс его начала, потому что снаружи мы не знаем то, как таргет в
реальности использует память, где у него находится стек, а где куча.
Но мы можем пойти на хитрость: с хоста обратиться к менеджеру памяти таргета и попросить у него
аллоцировать нам участок памяти.

```rust
#[no_mangle]
pub unsafe extern "C" fn toy_alloc(size: i32) -> i32 {
    let size_bytes: [u8; 4] = size.to_le_bytes();
    let mut buf: Vec<u8> = Vec::with_capacity(size as usize + size_bytes.len());
    // Первые 4 байта - это длина общая куска памяти, она нам еще понадобится в дальнейшем.
    buf.extend(size_bytes.iter());
    to_host_ptr(buf)
}

unsafe fn to_host_ptr(mut buf: Vec<u8>) -> i32 {
    let ptr = buf.as_mut_ptr();
    // Просто забываем о выделеном участке памяти, позволяя ему "утечь", таким образом
    // мы передаем его во владение хосту.
    mem::forget(buf);
    ptr as *mut c_void as usize as i32
}

#[no_mangle]
pub unsafe extern "C" fn toy_free(ptr: i32) {
    let ptr = ptr as usize as *mut u8;
    let mut size_bytes = [0u8; 4];
    ptr.copy_to(size_bytes.as_mut_ptr(), 4);
    // Вычитываем общую длину куска памяти для того, чтобы корректно выполнить его очистку.
    let size = u32::from_le_bytes(size_bytes) as usize;
    // Собираем вектор, о котором мы ранее "забыли" в методе `to_host_ptr` и таким образом даем
    // его деструктору вызваться нормальным образом и очистить ранее выделенный участок памяти.
    Vec::from_raw_parts(ptr, size, size);
}
```

В принципе, ничего хитрого на самом деле в этом нет, примерно этим же занимается [`wasm_bindgen`]

## Демонстрация результата

## Выводы

[watt]: https://github.com/dtolnay/watt
[libloading]: https://crates.io/crates/libloading
[`syn`]: https://crates.io/crates/syn
[`quote`]: https://crates.io/crates/quote
[`proc-macro2`]: https://crates.io/crates/proc-macro2
[bytecodealliance]: https://bytecodealliance.org/
[интерфейс модуля]: https://github.com/bytecodealliance/wasmtime/tree/master/crates/misc/rust
[`wasm_bindgen`]: https://habr.com/en/post/353230/
